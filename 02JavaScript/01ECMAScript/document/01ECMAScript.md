# 一、ECMAScript

# （专攻语法，深入学习参考网站）

# 1. JavaScript 是什么

```
JS网站学习：https://www.runoob.com/js/js-promise.html
1. JavaScript是一种运行在客户端的脚本语言 （Script 是脚本的意思） 

2. 脚本语言就是不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行的语言
```

# 2. 解释型语言和编译型语言

```
翻译器翻译的方式有两种：一个是编译，另外一个是解释, 两种方式之间的区别在于翻译的时间点不同

编译器是在代码执行之前进行编译，生成中间代码文件

解释器是在运行时进行及时解释，并立即执行(出现异常，后续代码不再执行)

所以编译型语言是先生成中间代码再一次性执行，解释型语言是边运行边解释边执行

前面我们所学的Java语言就是编译型语言，现在学的JS就是解释型语言
```

# 3. JavaScript的作用

```
1. 表单动态校验（密码强度检测）
2. 网页特效
3. 服务端开发(Node.js) 
4. 桌面程序(Electron) 
5. App(Cordova)
6. 控制硬件-物联网(Ruff) 
7. 游戏开发(cocos2d-js) 
. . .
```

# 4. HTML/CSS/JS 的关系 

```
1. HTML/CSS 标记语言--描述类语言 
	HTML 决定网页结构和内容( 决定看到什么 )，相当于人的身体 
	CSS 决定网页呈现给用户的模样( 决定好不好看 )，相当于给人穿衣服、化妆

2. JS 脚本语言--编程类语言 
	JS实现业务逻辑和页面控制( 决定功能 )，相当于人的各种动作 
```

# 5. 浏览器执行JS

```
1. 浏览器分成两部分：渲染引擎和 JS 引擎 
		1. 渲染引擎：
			用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit
		2. JS 引擎：
			也称为 JS 解释器，用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8

2. 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 
	
3. JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，
	所以 JavaScript 语言归为脚本语言，会逐行解释执行
```

# 6. JS组成部分

![image-20221103084249202](assets\image-20221103084249202.png)

```
1. ECMAScript
	ECMAScript规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准

2. DOM ——文档对象模型 
	文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口
	通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）

3. BOM ——浏览器对象模型
	BOM (Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构
	通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等
```

# 7. JS3种书写位置

```
1. 行内式 JS
	<input type="button" value="唐伯虎点秋香" onclick="alert('秋香姐')">

2. 内嵌 JS
	 <script>  
	 	alert('Hello World~!');  
	 </script>

3. 外部 JS文件 
	<script src="01JS3种书写位置.js"></script> 
```

# 8. 入门操作

```
1. JS注释

	1. 单行注释 
		// （ 快捷键 ctrl + / ） 
		
	2. 多行注释
		/* */ 用来注释多行文字（ 默认快捷键 alt + shift + a ） 

2. 简单操作
        alert('1'); // 弹出框
        confirm('2'); // 确认框
        prompt('3'); // 输入框
        console.log('5'); // 普通输出
        console.warn('6'); // 警告输出
        console.error('7'); // 错误输出	
        console.dir('看效果7') // 一般用于dump对象信息
```

# 9. JS声明变量特殊情况

```
1. 变量声明且赋值，赋的值
2. 变量只声明未赋值,undefined！
3. 变量未声明，未赋值，报错！
```

# 10. 数据类型分类

```
1. 简单数据类型 （Number,String,Boolean,Undefined,Null）
2. 复杂数据类型 （object)
```

![image-20221031130303308](assets\image-20221031130303308.png)

## 	1. 简单数据类型（值类型）

### 			1. 数字型 Number 

```
1. 十进制整型（数值型）
2. 八进制整型（数值型）0开头即八进制
3. 十六进制整型（数值型） 0x开头 即十六进制
4. 浮点型（数值型）
5. 数字型的最大值
6. 数字型的最小值
7. 无穷大
8. 无穷小
9. 非数字
10. 判断一个变量是否为非数字
11. 转换为数字型
		1. 普通转换
		2. 强制转换
12. 字符串转换数值型隐式转换 - * /
```

### 		2. 布尔型 Boolean 

```
1. true 真	false 假
2. true 参与加法运算当1来看
3. false 参与加法运算当 0来看
4. 转换为布尔型
	 代表空、否定的值会被转换为 false ，如 ''、0、NaN、null、undefined，其余值都会被转换为 true
```

### 		3. 字符串型 String 

```
字符串不可变指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间
1. 定义yjxz变量赋值
2. 输出yjxz字符串变量长度
3. + 拼接字符串
4. 从前往后查找字符在字符串的首次出现的位置,找不到返回-1
5. 从后往前查找字符在字符串的首次出现的位置，找不到返回-1
6. 返回指定位置的字符
7. 获取指定位置的ASCII码
8. 从指定位置开始截取指定长度的子字符串
9. 从指定位置开始截取到指定位置
10. 将字符串内第一个复合匹配情况的子串替换成另外一子串
11. 将字符串切分为数组
12. 字符串转大写
13. 字符串转小写
14. 转换为字符串
15. 双引号 "" 和 单引号''包裹起来的文本称为字符串
16. 字符串引号嵌套 可以用''包含"",也可以用"" 包含'',不能 单双引号搭配（'What on earth?"; // 报错）
17. 字符串转移字符
18. 去除字符串两边空格
```

![image-20221031200053832](assets\image-20221031200053832.png)

### 		4. Undefined 和 Null 

```
1. 变量声明未赋值 即 undefined（未定义数据类型）
2. 赋值undefined的变量与字符串类型相加情况
3. 赋值undefined的变量与数值类型相加情况
4. 赋值null空值的变量与字符串类型相加情况
5. 赋值null空值的变量与数值类型相加情况
```

## 	2. 复杂数据类型（引用类型）

```
JS中的Array、Math、Date、Object、自定义对象都属于复杂数据类型
```

# 11. typeof类型检测

# 12. JS数组

```
1. 利用new 创建空数组 
2. 利用数组字面量创建数组 []
3. 访问数组元素
4. 检测数组
5. 数组末尾添加一个或多个元素，并返回新的长度
6. 删除数组最后一个元素，并且返回被删除元素的值
7. 数组开头添加一个或多个元素，并返回新的长度
8. 删除数组第一个元素，并且返回被删除元素的值
9. 反转数组，返回新数组
10. 对数组进行排序，返回新数组
11. 查找給定元素的第一个索引，有则返回，否则返回-1
12. 查找給定元素的最后一个索引，有则返回，否则返回-1
13. 数组转换为字符串，逗号分隔每一项，返回字符串
14. 把数组中所有元素转换为一个字符串，分隔符指定
15. 连接两个或多个数组且不影响原数组，返回一个新的数组
16. 数组截取，返回被截取项目的新数组
17. 数组从指定位置开始删除指定个数的数组元素，返回删除项目的新数组，会影响原数组
18. 数组遍历forEach
19. 数组元素筛选filter()，返回新数组
20. 查找是否满足条件的元素
```

# 13. JS函数

```
1. 有名函数
2. 匿名函数
3. 函数调用,实参形参个数，参数匹配，输出正确结果
4. 函数调用,实参多于形参个数，参数不匹配，只取形参
5. 函数调用,实参少于形参个数，参数不匹配，多的形参定义为undefined
6. 不知函数到底接收多少参数采用arguments（伪数组）,只有函数才有 arguments对象  而且是每个函数都内置好了这个arguments
7. 函数无return返回值时，调用函数。返回值均为undefined
8. JS中，函数也属于对象
```

# 14. JS作用域

```
1. 全局作用域：整个script标签 或者是一个单独的js文件,只有浏览器关闭的时候才会销毁,比较占内存资源
2. 局部作用域（函数作用域）：只在函数内部起作用,程序执行完毕就会销毁,比较节约内存资源
3. ES6之前，JS的我没有块作用域
4. 作用域链：内部函数访问外部函数的变量，采取的是链式查找的方式来决定取那个值 这种结构我们称为作用域链   就近原则
```

# 15. JS预解析

```
预解析只会发生在通过 var 定义的变量和function 上

1. 变量预解析：变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升

2. 函数预解析：函数的声明会被提升到当前作用域的最上面，但是不会调用函数，调用则报错
```

# 16. JS对象

```
方式一：
	1. 利用对象字面量创建对象 {}
	2. 调用对象属性
	3. 调用对象行为

方式二：
	1. 构造函数创建空对象
	2. 为对象添加属性
	3. 为对象添加行为
	4. 调用对象属性
	5. 调用对象行为

方式三：
	1. 构造函数创建对象
-----------------
遍历对象
	1. 遍历对象for... in
	2. 遍历对象keys
```

# 17. JS内置对象

```
1. Math
	1.取绝对值
	2.向下取整
 	3. 向上取整
 	4. 四舍五入
 	5. 随机指定范围数字
 	6. 圆周率
 	7. 取最大值、最小值
 
2. Date
	1. 格式化日期 年月日 
	2. 当前日期的年
	3. 当前日期的月份（时区问题 需 +1）
	4. 当前日期对应几号
	5. 周几（周一返回 1，周日返回 0，最大即为 6）
	6. 写一个当前年月日星期几
	7. 封装时分秒
	8. 当前小时
	9. 当前分钟
	10. 当前秒数
```

# 18. ES6 中的类和对象

```
1. 创建Person类
2. 类的共有属性放到 constructor 内
3. 利用类创建对象 new
4. 对象添加属性
5. 对象添加方法
6. 类的继承
7. 其余操作，按照Java面向对象思想编写即可！
```

# 17. 构造函数创建对象

```
1. 构造函数创建对象
2. 实例成员就是构造函数内部通过this添加的成员
3. 静态成员就是通过构造函数本身上添加的成员
4. 静态成员只能通过构造函数来访问,不能通过对象来访问
5. 实例成员通过对象来访问
```

# 18. 原型

```
1. 构造函数创建对象 
2. 构造函数原型分配的函数是所有对象所共享的，
	每一个构造函数都有一个 prototype 属性指向另一个对象，这个对象的所有属性和方法，都会被构造函数拥有
3. 一般情况下,公共属性定义到构造函数里面, 公共方法定义到原型对象上
4. 对象身上系统会自动添加一个 __proto__ 指向我们构造函数的原型对象 prototype
5. 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
6. 原型链
	我们Person原型对象里面的__proto__原型指向的是 Object.prototype
	Object.prototype原型对象里面的__proto__原型 最终指向为 null
7. 利用原型扩展内置对象
```

# 19. 定义属性

```
Object.defineProperty() 定义新属性或修改原有的属性

1. 以前的对象添加和修改属性的方式

2. Object.defineProperty() 定义新属性或修改原有的属性

3. value: 设置属性的值（默认false）

4. writable: 值是否可以重写。true | false （默认false）

5. enumerable: 目标属性是否可以被枚举。true | false （默认false）

6.  configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false（默认false）

7. delete obj.address：修改不了，但是我可以删除属性
```

# 20. 函数进阶-函数定义

```
	1. 自定义函数(命名函数) 
	2. 函数表达式 (匿名函数)
	3. 利用 new Function('参数1','参数2', '函数体');
	4. 所有函数都是 Function 的实例(对象)
	5. 函数也属于对象
```

# 21. 函数进阶-函数调用

```
	1. 普通函数
	2. 对象的方法
	3. 构造函数
	4. 绑定事件函数
	5. 定时器函数
	6. 立即执行函数
```

# 22. 函数进阶-函数内this指向问题

![image-20221101173635724](assets\image-20221101173635724.png)

# 23. 函数进阶-函数内修改this指向问题

```
js修改this指向问题三种：call apply bind

1. call()主要用于继承（呼叫意思）
2. apply 主要跟数组有关：比如：借助于数学内置对象求数组最大值，参数必须是数组(伪数组)（应用意思）
3. bind 不会调用函数, 可以改变函数内部this指向（绑定意思）
```

# 24. 函数进阶-严格模式

```
1. 开启严格模式

2. 严格模式的变化
	1. 我们的变量名必须先声明再使用
	2.我们不能随意删除已经声明好的变量
	3. 严格模式下全局作用域中函数中的 this 是 undefined（不再是默认window）
	4. 严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错
	5. 定时器 this 还是指向 window
	6. 严格模式下函数里面的参数不允许有重名
```

# 25. 函数进阶-高级函数

```
接收函数作为参数或将函数作为返回值输出
```

# 26. 函数进阶-闭包

```
闭包（closure）指有权访问另一个函数作用域中变量的函数
无非就是一个作用域可以访问另外一个函数内部的局部变量

闭包作用：就是为了延伸变量的作用范围
```

# 27.ES6新特性

```
1. let（新增声明变量关键字let）
	let声明变量具有块级作用域特性
	var声明变量不具备块级作用域特性
	let声明变量不存在变量提升
	var声明的变量存在变量提升
	let声明变量存在暂时性死区问题
	
2. const（新增声明常量关键字const）
	1. const声明常量具有块级作用域
	2. const声明常量时必须赋值
	3. const声明常量赋值后，值不能修改
	
3. ES6新特性（数组和对象解构）
		数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量
		对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量

4. ES6新特性（箭头函数）
	箭头函数类似Java中的Lambda表达式写法
	1. 在箭头函数中 如果函数体中只有一句代码 并且代码的执行结果就是函数的返回值 函数体大括号可以省略
	2. 在箭头函数中 如果形参只有一个 形参外侧的小括号也是可以省略的
	3. 箭头函数不绑定this 箭头函数没有自己的this关键字 如果在箭头函数中使用this this关键字将指向箭头函数定义位置中的this

5. ES6新特性（剩余参数）
	剩余参数类似于Java语言中的量词参数，底层是个数组数据结构

6. ES6新特性（扩展运算符）
	1. 扩展运算符可以将数组拆分成以逗号分隔的参数序列
	2. 扩展运算符应用于数组合并
	3. 利用剩余参数合并数组
	4. 利用扩展运算符将伪数组转换为真正的数组
	5. 扩展运算符用在对象上为深拷贝
```

# 28. Array数组方法扩展

```
1. Array.from()（构造函数方法） 
	将类数组或可遍历对象转换为真正的数组
	方法还可以接受第二个参数，作用类似于数组的map方法，
	遍历时还可以对每个元素进行处理，将处理后的值放入返回的数组（简单来说映射）

2. find()（实例方法）
	用于找出第一个符合条件的数组成员，如果没有找到返回undefined 

3. findIndex()（实例方法）
	用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1

4. includes() （实例方法）
	表示某个数组是否包含给定的值，返回布尔值
```

# 29. String字符串方法扩展

```
1. 模板字符串
	1. ES6新增的创建字符串的方式，使用反引号定义
	2. 模板字符串中可以解析变量
	3. 模板字符串中可以换行书写
	4. 在模板字符串中可以调用函数

2. startsWith() 和 endsWith() （实例方法）
	1. startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值
	2. endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值 

3. repeat()（实例方法）
	repeat方法表示将原字符串重复n次，返回一个新字符串
```

# 30. 扩展数据结构Set

```
ES6 提供了新的数据结构 Set，它类似于数组，但是成员的值都是唯一的，没有重复的值（类似Java数据结构Set）

相关实例方法
	1. add(value)：添加某个值，返回 Set 结构本身 
	2. delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 
	3. has(value)：返回一个布尔值，表示该值是否为 Set 的成员 
	4. clear()：清除所有成员，没有返回值 

遍历：
	与数组一样的遍历方法forEach，无返回值
```

# 31. 正则表达式（深入官网学习）

```
正则表达式网站学习：https://www.runoob.com/regexp/regexp-tutorial.html
正则表达式在线测试：https://c.runoob.com/front-end/854/

1. 正则-正则表达式入门
	1. 创建正则对象语法
		语法1：(Perl 风格)
			var reg = /pattern/ [flags]
		语法2：构造函数创建正则对象
			new RegExp("pattern", ["flags"])
	
	2. 定义字符串
	3. 定义正则表达式
	4. test测试指定字符串是存在（存在返回true，不存在返回false）
	5. 模式 i 忽视大小写
	6. 全局查找（某一子串符合规则即为true）
	7. match将查找到的结果字符串作为数组返回
	8. []里面字符任意出现一个，即匹配成功
	9. 量词 次数  ?对应0~1  *对应0~n    +对应1~n    .对应任意字符
	10. 量词  次数 {n}指定出现n次 	{n,m}出现n~m范围内的次数即Ok	 {n,}出现n次以上（{} 中不能出现空格）

2. 正则-字符串与正则
	1. split("") 拆分字符  返回数组（案例：数字拆分字符串，返回数组）
			^ 脱字符 负向类 不包含
	2. search()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串
		（搜索字符串中是否有指定内容，如果有返回指定内容第一次出现的起始位置，没有返回-1）
	3. match()使用正则表达式对字符串执行查找，并将包含查找的结果作为数组返回
		默认match只会找到第一个符合的内容，就停止检索，可以设置全局匹配模式 g 进行全局检索
		预定义 \d \w [a-zA-Z0-9_]单词字符串 字母数字下划线（预定类直接查找提供的正则表达式资料或官网）
	4. replace()将字符串中指定内容替换未为新得内容,返回新字符串
		 第一个参数可以为字符串（替换第一个符合规则的，想全部替换，采取replaceAll），
		 也可以为正则对象（默认只会替换一个，要想全局替换，全局匹配模式g）

3. 正则-RegExp对象的属性
	1. 定义正则规则
	2. exec() 方法用于检索字符串中的正则表达式的匹配,匹配成功返回一个数组，否则返回一个null
	3. 原字符串
    4. myreg.source: 返回模式匹配所用的文本
    5. myreg.ignoreCase: 忽视大小写是否已经设置（返回布尔值）
    6. myreg.global: 全局匹配是否设置（返回布尔值）
    7. myreg.multiline: 多行搜索是否设置 有换行标记\n （返回布尔值）
    8. arr: 匹配结果
    9. arr.index: 匹配结果在原字符串中起始的索引（以0开始）
    10. myreg.lastIndex: 匹配结果的最后字符的下一个字符在原字符串的位置（设置标志 g 才能使用）
    11. test(): test测试字符串是否符合规则（符合规则返回true，不符合规则返回false）
4. 正则-分组-捕获性分组
	 1. 在正则表达式中,使用“（）”进行分组，一对圆括号括起来的表达式就是一个分组
	 2. 捕获: 将匹配到的子表达式保存在RegExp对象中
	 3. 分组后所保存的子表达式
	 4. 反向引用所指向的子表达式
	 5. 捕获性分组工作模式（） 会把每个分组里匹配的值保存起来， 方便接下来的操作
	 6. 捕获先整体再局部（\s空白字符）
	 7. 例一：倒置字符串
	 	方法一：通过exec函数
	 	方法二：通过属性$ 1-9
	 	方法三：通过替换（）
	 8. 例二 ：反向引用
	 	捕获可以反向引用（在表达式中直接使用某个分组的内容)
	 	从左向右， 分组以左括号为标志， 第一个出现的分组的组号为1， 第二个为2， 以此类推

5. 正则-分组-非捕获性分组
	1. 在js中
		 ()表示捕获分组，() 会把每个分组里的匹配的值保存在RegExp对象中，使用$n(n是一个数字，表示第n个捕获组的内容)访问
		 (?:)表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来
	2. 前瞻、负前瞻、本身、后顾、负后顾
		前瞻：
			A(?=B)   //查找B前面的A
		负前瞻：
			A(?!B)   //查找后面不是B的A
		本身：
			(?:B)
		后顾：
			(?<=B)A   //查找B后面的A
		负后顾：
			(?<!B)A   //查找前面不是B的A
			
6. 零宽断言
	 1. js正则表达式只支持零宽先行断言
	 	零宽先行断言可以分为正向零宽先行断言（判断字符后面必须匹配regexp）和负向零宽先行断言(判断字符后面不能匹配regexp)
	 2. 正向零宽先行断言
	 3. 负向零宽先行断言
	 	返回的结果是null,这是因为match方法没有匹配到结果时的返回值
	 	可以看出
	 		js中的零宽断言只能实现断言位置后面能不能匹配某个regexp
	 		不能判断断言位置的前面能不能匹配某个regexp，即不支持零宽后发断言
```

# 32. JS执行机制

```
JavaScript语言是单线程，同一个时间只能做一件事！

单线程就意味着所有任务需要排队，前一个任务结束，才会执行后一个任务

这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉

解决这个问题：HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，于是，JS 中出现了同步和异步！

同步：
	前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的！

异步：
	不必等到一个任务执行完成，就可以执行另外一个任务，程序的执行顺序与任务的排列顺序不一一定一致、异步的！

同步任务：
	同步任务都在主线程上执行，形成一个执行栈

异步任务：
	JS 的异步是通过回调函数实现的
	一般而言，异步任务有以下三种类型: 
		1. 普通事件，如 click、resize 等 
		2. 资源加载，如 load、error 等 
		3. 定时器，包括 setInterval、setTimeout 等 
		异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）

JS执行机制：
	1. 先执行执行栈中的同步任务
	2. 异步任务（回调函数）放入任务队列中
	3. 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，
		于是被读取的异步任务结束等待状态，进入执行栈，开始执行

为什么JS是单线程：
	作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM
	如果JS是多线程的，现在有一个线程要修改元素中的内容, 一个线程要删除该元素, 这时浏览器应该以哪个线程为准，确定不下来！
```

# 33. EventLoop

```
上述可知：

	JavaScript 是一门单线程执行的编程语言，也就是说，同一时间只能做一件事情

	单线程执行任务队列的问题：
		如果前一个任务非常耗时，则后续的任务就不得不一直等待，从而导致程序假死的问题


	为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类：
		1. 同步任务（synchronous）
			又叫做非耗时任务，指的是在主线程上排队执行的那些任务
			只有前一个任务执行完毕，才能执行后一个任务
		2. 异步任务（asynchronous）
			又叫做耗时任务，异步任务由JavaScript 委托给宿主环境进行执行
			当异步任务执行完成后，会通知JavaScript 主线程执行异步任务的回调函数
```

![image-20221109103221234](assets\image-20221109103221234.png)

![image-20221109103339383](assets\image-20221109103339383.png)

# 34. 宏任务和微任务

## 1. 什么是宏任务和微任务

```
JavaScript 把异步任务又做了进一步的划分，异步任务又分为两类，分别是
	1. 宏任务（macrotask）
		1. 异步Ajax 请求
		2. setTimeout、setInterval
		3. 文件操作
		4. 其它宏任务
	2. 微任务（microtask）
		Promise.then、Promise.catch 和 Promise.finally
		其它微任务
```



## 2. 宏任务和微任务的执行顺序

```
每一个宏任务执行完之后，都会检查是否存在待执行的微任务，如果有，则执行完所有微任务之后，再继续执行下一个宏任务
```

![image-20221109123810713](assets\image-20221109123810713.png)

## 3. 去银行办业务的场景

```
1. 小云和小腾去银行办业务，首先，需要取号之后进行排队
	宏任务队列
	
2. 假设当前银行网点只有一个柜员，小云在办理存款业务时，小腾只能等待
	单线程，宏任务按次序执行
	
3. 小云办完存款业务后，柜员询问他是否还想办理其它业务？
	当前宏任务执行完，检查是否有微任务

4. 小云告诉柜员：想要买理财产品、再办个信用卡、最后再兑换点马年纪念币？
	执行微任务，后续宏任务被推迟

5. 小云离开柜台后，柜员开始为小腾办理业务
	所有微任务执行完毕，开始执行下一个宏任务
```

