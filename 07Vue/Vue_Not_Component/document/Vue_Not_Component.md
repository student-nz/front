# Vue_No_Compment（Vue2）

# 1. 什么是Vue

```
1. Vue是一套用于构建用户界面的前端框架

2. 用户界面：编写结构 + 美化样式 + 处理交互
		非组件化开发编写：
			编写结构（HTML) + 美化样式（CSS) + 处理交互（JS）
		组件化开发编写：
			编写结构（template) + 美化样式（style) + 处理交互（script）

3. vue全家桶
	1. vue（核心库）
	2. vue-router（路由方案）
	3. vuex（状态管理方案）
	4. vue组件库（快速搭建页面UI效果的方案）

4. 辅助vue项目开发的一系列工具
	1. vue-cli（npm 全局包：一键生成工程化的vue 项目-基于webpack、大而全）
	2. vite（npm 全局包：一键生成工程化的vue 项目-小而巧）
	3. vue-devtools（浏览器插件：辅助调试的工具）
	4. vetur（vscode插件：提供语法高亮和智能提示）
```

# 2. Vue的版本

```
1. 1.x 版本的vue（几乎被淘汰）
2. 2.x 版本的vue（目前企业主流版本，未来必被vue3替代）
3. 3.x 版本的vue（2020-09-19 发布，生态还不完善，尚未企业流行应用，未来趋势）

vue3.x 和 vue2.x 版本的对比：
	vue2.x 中绝大多数的 API 与特性，在vue3.x 中同样支持，
	同时，vue3.x 新增了 3.x 所特有的功能、废弃了 2.x 中的一些旧功能
	
	3.x 新增的功能：
		例如：组合式API、多根节点组件、更好的TypeScript 支持等
		
	3.x 废弃 2.x 的一些旧功能：
		例如：过滤器、不再支持$on，$off 和$once 实例方法等

官方文档的迁移指南：
	https://v3.vuejs.org/guide/migration/introduction.html
```

# 3. Vue调试工具

```
Chrome 浏览器为例子：
	1. 安装vue-devtools调试工具
	
	2. 配置Chrome 浏览器中的vue-devtools
		选择更多工具-> 扩展程序-> Vue.js devtools 详细信息（配置信息如图1）
		
	3. 修改完配置项，须重启浏览器才能生效！
	
	4. 使用vue-devtools 调试vue 页面

注意：
	vue2和vue3的浏览器调试工具不能交叉使用（就是只能选其一）
```

## 图1

![image-20221112123743469](assets\image-20221112123743469.png)

## 图2

![image-20221112123935812](assets\image-20221112123935812.png)

# 4. Vue基础模板

```
1.下载导入Vue.js

2.创建一个Vue的实例对象

3.告诉Vue的实例对象, 将来需要控制界面上的哪个区域

4.告诉Vue的实例对象, 被控制区域的数据是什么
```

# 5. MVVM设计模式

```
1.MVVM设计模式（MVVM设计模式中由3部分组成）
	1. M : Model      数据模型(保存数据, 处理数据业务逻辑)
	2. V : View       视图(展示数据, 与用户交互)
	3. VM: View Model 数据模型和视图的桥梁(M是中国人, V是美国人, VM就是翻译)

2. MVVM设计模式的特点
	MVVM设计模式最大的特点就是支持数据的双向传递
	数据可以从 M -> VM -> V
	也可以从   V -> VM -> M

3. Vue中MVVM的划分（Vue是基于MVVM设计模式的—）
	1. 被控制的区域: View
	2. Vue实例对象 : View Model
	3. 实例对象中的data: Model

4. MVVM的工作原理
	ViewModel 作为MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起
	当数据源发生变化时，会被ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构
	当表单元素的值发生变化时，也会被VM 监听到，VM 会把变化过后最新的值自动同步到Model 数据源中
```

## MVVM工作原理

![image-20221111105314447](assets\image-20221111105314447.png)



# 6. Vue数据绑定

## 	1. 单向数据绑定

```
单向数据绑定：
	"数据"交给"Vue实例对象", "Vue实例对象"将数据交给"界面"
	Model  ->  View Model  ->   View
```

## 	2. 双向数据绑定

```
双向数据绑定：
	1. 默认情况下Vue只支持数据单向传递 M -> VM -> V
	2. Vue是基于MVVM设计模式的, 提供了双向传递的能力
	3. 在<input>、<textarea> 及 <select> 元素上可以用 v-model 指令创建双向数据绑定
	4. v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值，而总是将 Vue 实例的数据作为数据来源
```

# 7. Vue指令

## 	1. 什么是指令

```
指令（directives）
什么是指令：
	指令就是Vue内部提供的一些自定义属性,
	这些属性中封装好了Vue内部实现的一些功能
	只要使用这些指令就可以使用Vue中实现的这些功能
```

## 	2. v-once

```
v-once指令：
	让界面不要跟着数据变化, 只渲染一次
```

## 	3. v-cloak

```
Vue数据绑定过程:
	1. 会先将未绑定数据的界面展示给用户
	2. 然后再根据模型中的数据和控制的区域生成绑定数据之后的HTML代码
	3. 最后再将绑定数据之后的HTML渲染到界面上
	正是在最终的HTML被生成渲染之前会先显示模板内容,所以如果用户网络比较慢或者网页性能比较差, 那么用户会看到模板内容

如何解决这个问题：
	利用v-cloak配合 [v-cloak]:{display: none}默认先隐藏未渲染的界面
	等到生成HTML渲染之后再重新显示

v-cloak指令作用：
	数据渲染之后自动显示元素	
```

## 	4. v-text和v-html

```
v-text相当于原生js的innerText
v-html相当于原生js的innerHTML
```

## 	5. v-if和v-else和-v-else-if

```
1.v-if 
	条件渲染: 取值true,渲染元素m,否则，不渲染元素（即创建不创建元素）
	v-if可以从模型中获取数据，v-if也可以直接赋值一个表达式
2. v-else
	v-else指令可以和v-if指令配合使用, 当v-if不满足条件时就执行v-else就显示v-else中的内容
	v-else不能单独出现,v-if和v-else中间除了v-else-if可以出现，不能出现其它内容
3. v-else-if
	v-else-if可以和v-if指令配合使用, 当v-if不满足条件时就依次执行后续v-else-if, 哪个满足就显示哪个
	v-else-if不能单独出现,v-if和v-else-if中间不能出现其它内容
```

## 6. v-show

```
v-show和v-if的能够一样都是条件渲染, 取值为true就显示, 取值为false就不显示

v-if和v-show区别:
	1. 实现原理不同：
		v-if 指令会动态地创建或移除DOM 元素，从而控制元素在页面上的显示与隐藏；
		v-show 指令会动态为元素添加或移除style="display: none;" 样式，从而控制元素的显示与隐藏；
	2. 性能销毁不同：
		v-if有更高的切换开销，而v-show有更高的初始渲染开销
			1. 如果需要非常频繁地切换，则使用v-show 较好（应用场景）
			2. 如果在运行时条件很少改变，则使用v-if 较好（应用场景）
```

## 7. v-for

```
1. v-for指令相当于JS中的for in循环, 可以根据数据多次渲染元素

2. 可以遍历 数组, 字符, 数字, 对象

3. v-for为了提升性能, 在更新已渲染过的元素列表时，会采用“就地复用”策略，因为这个策略, 在某些时刻会导致数据混乱
	例如: 在列表前面新增了内容
	1. 为解决这个问题, 可以在渲染列表时给每一个元素加上一个独一无二的key
		v-for在更新已经渲染过的元素列表时, 会先判断key是否相同, 如果相同则复用, 如果不同则重新创建
	2. key属性注意：
		不能使用index的作为key,因为当列表的内容新增或者删除时index都会发生变化
```

## 8. v-bind

```
1.什么是v-bind指令
	在企业开发中想要给"元素"绑定数据, 我们可以使用{{}}, v-text, v-html
	但是如果想给"元素的属性"绑定数据, 就必须使用v-bind
	所以v-bind的作用是专门用于给"元素的属性"绑定数据的

2.v-bind格式
	1. v-bind:属性名称="绑定的数据"
	2. :属性名称="绑定的数据"

3.v-bind特点
	赋值的数据可以是任意一个合法的JS表达式
	例如: :属性名称="age + 1"

4. vue-bind绑定类名
	1. v-bind指令的作用
		v-bind指令给"任意标签"的"任意属性"绑定数据
		对于大部分的属性而言我们只需要直接赋值即可, 例如:value="name"
		但是对于class和style属性而言, 它的格式比较特殊
	2.通过v-bind绑定类名格式
		:class="['需要绑定类名', ...]"
	3. 注意
		1. 直接赋值一个类名(没有放到数组中)默认会去Model中查找，Model无对应类名则无效
			:class="需要绑定类名"
		2. 数组中的类名没有用引号括起来也会去Model中查找，Model无对应类名则无效
			:class="[需要绑定类名]"
		3. 数组的每一个元素都可以是一个三目运算符按需导入
			:class="[flag?'active':'']"
		4. 可以使用对象来替代数组中的三目运算符按需导入
			:class="[{'active': true}]"
		5. 绑定的类名太多可以将类名封装到Model中
			obj: {
				'color': true,
				'size': true,
				'active': false
			}
	4. 绑定类名企业应用场景
		从服务器动态获取样式后通过v-bind动态绑定类名
		这样就可以让服务端来控制前端样式
		常见场景: 618 双11等

5. v-bind绑定样式
	1.如何通过v-bind给style属性绑定数据
		1. 将数据放到对象中
			:style="{color:'red','font-size':'50px'}"
		2. 将数据放到Model对象中
			obj: {
				color: 'red',
				'font-size': '80px',
			}
		3.注意
			1. 和绑定类名一样, 默认情况下v-bind回去Model中查找, 找不到所以没有效果
			2. 只需要将样式代码放到对象中赋值给style即可,但是取值必须用引号括起来
			3. 如果样式的名称带-, 必须用引号括起来才可以
			4. 如果Model中保存了多个样式的对象 ,想将多个对象都绑定给style, 那么可以将多个对象放到数组中赋值给style即可
```

## 9. v-on

```
1. v-on指令专门用于给元素绑定监听事件
2. v-on指令格式
	1. v-on:事件名称="回调函数名称"
	2. @事件名称="回调函数名称"
	例如：原生DOM 对象有onclick、oninput、onkeyup等原生事件，
		替换为vue 的事件绑定形式后，分别为：v-on:click、v-on:input、v-on:keyup
		
3.注意:
	1.通过v-on来绑定监听事件, 在指定事件名称的时候不需要写on，但在赋值的时候必须赋值一个回调函数的名称，否则报错！
	2.当绑定的事件被触发后, 会调用Vue实例的methods对象中对应的回调函数
	3.其实v-on后面并非一定要是回调函数！
	
4. v-on修饰符
	.once    	只触发一次回调					 - 绑定的事件只触发1次
	.prevent 	调用 event.preventDefault() 	- 阻止默认行为（例如：阻止a 连接的跳转、阻止表单的提交等）
	.stop    	调用 event.stopPropagation() 	- 阻止事件冒泡
	.self    	只当事件是从侦听器绑定的元素本身触发时才触发回调 - 只有在event.target是当前元素自身时触发事件处理函数
	.capture 	以捕获模式触发当前的事件处理函数
	
	注意：
		1. 默认情况下事件的回调函数可以反复的执行, 只要事件被触发就会执行
		2. 如果想让事件监听的回调函数只执行一次, 那么就可以使用.once修饰符
		3. 如果想阻止元素的默认行为, 那么可以使用.prevent修饰符
		4. 默认情况下载嵌套的元素中, 如果都监听了相同的事件, 那么会触发事件冒泡,如果想阻止事件冒泡, 那么可以使用.stop修饰符
		5. 如果想让回调只有当前元素触发事件的时候才执行, 那么就可以使用.self修饰符
		6. 默认情况下是事件冒泡, 如果想变成事件捕获, 那么就需要使用.capture修饰符

5. v-on回调函数相关
	1. 绑定回调函数名称的时候, 后面可以写()也可以不写
		v-on:click="myFn"
		v-on:click="myFn()"
	
	2. 可以给绑定的回调函数传递参数
		v-on:click="myFn('lnj', 33)"

	3. 如果在绑定的函数中需要用到data中的数据必须加上this

6. v-on按键修饰符
	1. 按键修饰符的作用：
		就是可以通过按键修饰符监听特定按键触发的事件
	2.什么是按键修饰符
		例如: 可以监听当前事件是否是回车触发的, 可以监听当前事件是否是ESC触发的等
	2.按键修饰符分类
		1. 系统预定义修饰符
		2. 自定义修饰符

7. v-model指令修饰符
	.number		自动将用户的输入值转为数值类型		<input v-model.number="age" />
	.trim		自动过滤用户输入的首尾空白字符		<input v-model.trim="msg" />
	.lazy		在“change”时而非“input”时更新	 <input v-model.lazy="msg" />

8. $event
	$event 是vue 提供的特殊变量，用来表示原生的事件参数对象event，
	$event 可以解决事件参数对象event 被覆盖的问题
```

## 10. 自定义指令

### 	1. 自定义全局指令

```
1. 为什么要自定义指令
	某些指令不能满足我们的实际需求，需自定义指令满足需求
	
2. 语法：
	Vue.directive('自定义指令名称', {
    	生命周期名称: function (el) {
        	指令业务逻辑代码
    	}
	});

3. 指令生命周期
	自定义指令时一定要明确指令的业务逻辑代码更适合在哪个阶段执行（两个生命周期）
	1. bind: 指令被绑定到元素上的时候执行
	2. inserted: 绑定指令的元素被添加到父元素上的时候执行

4. directive方法接收两个参数
    	第一个参数: 指令的名称
    	第二个参数: 对象

5.  注意: 
		指令使用时需要加上v-, 自定义时不需要加上v-
```

### 2. 自定义指令参数

```
1.自定义指令参数
	使用官方指令时我们可以给指令传参，例如: v-model="name"，自定义指令统一可以对指令传参
	
2.获取自定义指令传递的参数
	执行自定义指令时，会传递el（元素本身对象）给我们，还会传递一个对象，这个对象保存了指令传递过来的参数
```

### 3. 自定义局部指令

```
1.自定义全局指令特点
	在任何一个Vue实例控制的区域中都可以使用
	
2.自定义局部指令的特点
	只能在自定义的那个Vue实例中使用

3.如何自定义局部指令（给创建Vue实例时传递的对象添加）
	directives: {
    	// key: 指令名称
    	// value: 对象
    	'color': {
        	bind: function (el, obj) {
            	el.style.color = obj.value;
        	}
    	}
```

# 8. Vue计算属性和函数

```
计算属性（computed）和函数（methods）
1.插值语法特点
	可以在{{}}中编写合法的JavaScript表达式

2.在插值语法中编写JavaScript表达式缺点
	1. 没有代码提示
	2. 语句过于复杂不利于我们维护

3.如何解决?
	对于任何复杂逻辑，都应当使用计算属性

4. 计算属性和函数区别：
	通过计算属性和函数都能拿到处理后的数据，
	为什么还要用计算属性，原因如下：
		1. 函数"不会"将计算的结果缓存起来, 每一次访问都会重新求值
		2. 计算属性"会"将计算的结果缓存起来, 只要数据没有发生变化, 就不会重新求值
		（也可以说成只要返回的结果没有发生变化, 那么计算属性就只会被执行一次）
			
5. 计算属性的应用场景
	由于计算属性会将返回的结果缓存起来，
	所以如果返回的数据不经常发生变化,
	那么使用计算属性的性能会比使用函数的性能高

6. 注意：
	虽然在定义计算属性的时候是通过一个函数返回的数据，
	但是在使用计算属性的时候不能在计算属性名称后面加上()，
    因为它是一个属性不是一个函数(方法)
```

# 9. Vue过滤器

## 	1. 自定义全局过滤器

```
过滤器（filters）
1.什么是过滤器
	过滤器和函数和计算属性一样都是用来处理数据的，但是过滤器一般用于格式化插入的文本数据

2.自定义全局过滤器语法：
	Vue.filter("过滤器名称", 过滤器处理函数):

3.如何使用全局过滤器
	1. {{msg | 过滤器名称}}
	2. :value="msg | 过滤器名称"

4. filter方法接收两个参数：
		第一个参数: 过滤器名称
		第二个参数: 处理数据的函数
		默认情况下处理数据的函数接收一个参数, 就是当前要被处理的数据
		（也就是该函数第一个参数永远是管道符（|）前面待处理的值，第二个参数开始才是过滤器传递过来的参数）
	
6. 注意
	1. 只能在插值语法和v-bind中使用
	2. 过滤器可以连续使用
```

## 2. 自定义局部过滤器

```
1.自定义全局过滤器特点
	在任何一个Vue实例控制的区域中都可以使用

2.自定义局部过滤器的特点
	只能在自定义的那个Vue实例中使用

3.如何自定义一个局部指令（给创建Vue实例时传递的对象添加）
	filters: {
    	// key: 过滤器名称
    	// value: 过滤器处理函数
    	'formartStr': function (value) {}
	}
```

# 10. Vue组件

## 	1. 自定义全局组件

```
组件（component）
Vue两大核心: 
	1.数据驱动界面改变 
	2.组件化

什么是组件：
	1. 在前端开发中组件就是把一个很大的界面拆分为多个小的界面, 每一个小的界面就是一个组件
	2. 将大界面拆分成小界面就是组件化

组件化的好处：
	1. 可以简化Vue实例的代码
	2. 可以提高复用性

自定义全局组件（两种方式，案例演示）
```

## 	2. 自定义局部组件

```
1.自定义全局组件特点
	在任何一个Vue实例控制的区域中都可以使用
2.自定义局部组件特点
	只能在自定义的那个Vue实例控制的区域中可以使用
3.如何自定义一个局部组件
	在vue实例中新增components: {}
	在{}中通过key/vue形式注册组件
	components:{
		abc: {}
	 }
```

## 3. 组件中的data和methods

```
1.自定义组件中的data和methods
	Vue实例控制的区域相当于一个大的组件, 在大组件中我们可以使用data和methods
	而我们自定义的组件也是一个组件, 所以在自定义的组件中也能使用data和methods

2.自定义组件中data注意：
	在自定义组件中不能像在vue实例中一样直接使用data，而是必须通过返回函数的方式来使用data

3. 组件中的data为什么是一个函数
	因为自定义组件可以复用, 为了保证复用时每个组件的数据都是独立的, 所以必须是一个函数
```

## 4. 组件切换

```
1. 对于普通的元素我们可以通过v-if来实现切换
2. 对于组件我们也可以通过v-if来实现切换
3. 因为组件的本质就是一个自定义元素
```

## 5. 动态组件

```
<component v-bind:is="需要显示组件名称"></component>
component我们称之为动态组件, 也就是你让我显示谁我就显示谁

为什么可以通过v-if切换还要有component：
	因为component可以配合keep-alive来保存被隐藏组件隐藏之前的状态
```

## 6. 父子组件

```
1.什么是父子组件?
	在一个组件中又定义了其它组件就是父子组件
	其实局部组件就是最简单的父子组件, 因为我们说过可以把Vue实例看做是一个大组件
	我们在Vue实例中定义了局部组件, 就相当于在大组件里面定义了小组件, 所以实局部组件就是最简单的父子组件

2.如何定义其它的父子组件？
	自定义组件中可以使用data, 可以使用methods. 当然自定义组件中也可以使用components
	所以我们也可以在自定义组件中再定义其它组件
```

## 7. 父组件数据传递子组件

```
1. 父子组件数据传递?
	在Vue中子组件是不能访问父组件的数据的,
	如果子组件想要访问父组件的数据, 必须通过父组件传递

2. 如何传递数据
	在父组件中通过v-bind传递数据
   	传递格式 v-bind:自定义接收名称 = "要传递数据"
   	
3. 在子组件中通过props接收数据
   	接收格式 props: ["自定义接收名称"]
```

## 8. 父子组件方法传递

```
1.父子组件方法传递
	在Vue中子组件是不能访问父组件的方法的,
	如果子组件想要访问父组件的方法, 必须通过父组件传递

2.如何传递方法
	1. 在父组件中通过v-on传递方法
   		传递格式 v-on:自定义接收名称 = "要传递方法"
	2. 在子组件中自定义一个方法
	3. 在自定义方法中通过 this.$emit('自定义接收名称'); // 触发传递过来的方法
```

## 9. 子组件数据传递父组件

```
我们可知父组件数据传递子组件，子组件不能数据传递父组件，但是我们可以借助父子组件方法传递思想，达到子组件数据传递父组件！
	1. 父组件的方法传递给子组件
	2. 子组件中调用父组件中的方法
	3. 调用方法的时候给方法传递参数，传递的参数, 就是我们需要传递的数据
```

## 10. 组件命名规范

```
1. 注册组件的时候使用了"驼峰命名", 那么在使用时需要转换成"短横线分隔命名"
	例如: 注册时: myFather  ->  使用时: my-father

2. 在传递参数的时候如果想使用"驼峰名称", 那么就必须写"短横线分隔命名"
	例如: 传递时: parent-name="name" ->  接收时: props: ["parentName"]

3. 在传递方法的时候不能使用"驼峰命名", 只能用"短横线分隔命名"
	@parent-say="say"  -> this.$emit("parent-say");
```

## 11. 组件多级传递

```1
数据和方法的多级传递：
	在Vue中如果儿子想使用爷爷的数据, 必须一层一层往下传递
	在Vue中如果儿子想使用爷爷的方法, 必须一层一层往下传递
```

## 12. 组件插槽

```
1.什么是插槽?
	默认情况下使用子组件时在子组件中编写的元素是不会被渲染
	如果子组件中有部分内容是使用时才确定, 那么我们就可以使用插槽
	插槽就是在子组件中放一个"坑", 以后由父组件来"填"

2. 什么是匿名插槽?
	没有名字的插槽, 会利用使用时指定的内容替换整个插槽（若无指定内容，就插槽中默认数据）
	注意：
		如果有多个匿名插槽, 每一个匿名插槽都会被指定的内容替换（虽然写多个匿名插槽不会报错, 但是在企业开发只推荐写一个）

3. 什么是具名插槽？
	默认情况下有多少个匿名插槽, 我们填充的数据就会被拷贝多少份，这导致了所有插槽中填充的内容都是一样的
	如果我们想给不同的插槽填充不同的内容，可以使用具名插槽！
	具名插槽使用：
		通过插槽的name属性给插槽指定名称，在使用时可以通过slot="name"方式, 指定当前内容用于替换哪一个插槽
		注意：如果没有指定要替换哪个插槽中的内容, 则不会被替换

4. 什么是v-slot指令?
	1. v-slot指令是Vue2.6中用于替代slot属性的一个指令
	2. 在Vue2.6之前, 我们通过slot属性告诉Vue当前内容填充到哪一个具名插槽
	3. 从Vue2.6开始, 我们通过v-slot指令告诉Vue当前内容填充到哪一个具名插槽
	4. v-slot指令只能用在template标签上，可以使用#号替代v-slot！、

5. 什么是作用域插槽？
	1.什么是作用域插槽
		作用域插槽就是带数据的插槽, 就是让父组件在填充子组件插槽内容时也能使用子组件的数据
	2.如何使用作用域插槽
		1. 在slot中通过 v-bind:数据名称="数据名称" 方式暴露数据
		2. 在父组件中通过 <template slot-scope="作用域名称"> 接收数据
		3. 在父组件的<template></template>中通过 作用域名称.数据名称 方式使用数据
	3. 作用域插槽的应用场景: 
		子组件提供数据, 父组件决定如何渲染
	4. v-slot指令
		1. 在 2.6.0 中，具名插槽和作用域插槽引入了一个新的统一的语法 (即 v-slot 指令)，取代了 slot 和 slot-scope！
		2. 除了可以通过v-slot指令告诉Vue内容要填充到哪一个具名插槽中，
			还可以通过v-slot指令告诉Vue如何接收作用域插槽暴露的数据
		3. v-slot:插槽名称="作用域名称"
```

# 11. 全局数据共享Vuex

```
1.什么是Vuex?
	vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据，保存到 vuex 中，
	方便整个程序中的任何组件直接获取或修改我们的公共数据
	只有需要共享的才放到vuex上, 不需要共享的数据依然放到组件自身的data上

2. vuex具体步骤查看（43vuex-共享数据）

3. vuex修改数据具体操作查看（44vuex-共享数据）

3. 什么是vuex中的getters
	Vuex的getters属性和组件的计算属性一样, 会将数据缓存起来, 只有数据发生变化才会重新计算
```

# 12. 前端路由VueRouter

```
1.什么是Vue Router?
	Vue Router和v-if/v-show一样, 是用来切换组件的显示的
	v-if/v-show是标记来切换(true/false)
	Vue Router用哈希来切换(#/xxx)
	比v-if/v-show强大的是Vue Router不仅仅能够切换组件的显示, 还能够在切换的时候传递参数

2.Vue Router使用查看（46vuerouter-基本使用）
	1. 导入Vue Router
	2. 定义路由规则
	3. 根据路由规则创建路由对象
	4. 将路径对象挂载到Vue实例中
	5. 修改URL哈希值
	6. 通过<router-view>渲染匹配的组件

3. 重定向路由
	1.什么是router-link?
		通过a标签确实能设置URL的hash,但不专业
		在Vue Router中提供了一个专门用于设置hash的标签 router-link
	2.router-link特点
		默认情况下Vue会将router-link渲染成a标签, 但是我们可以通过tag来指定到底渲染成什么
	3.给router-link设置选中样式
		默认情况下我们可以通过重写router-link-active类名来实现设置选中样式
		但是我们也可以通过linkActiveClass来指定选中样式

4.重定向路由
	{ path: '被重定向值', redirect: '重定向之后的值' }

5. 传递参数
	只要将Vue Router挂载到了Vue实例对象上, 我们就可以通过vue.$route拿到路由对象
	只要能拿到路由对象, 就可以通过路由对象拿到传递的参数
		1. 方式一: 通过URL参数参数(?key=value&key=value), 通过this.$route.query获取
		2. 方式二: 通过占位符传递(路由规则中/:key/:key, 路径中/value/value), 通过this.$route.params获取

6. 嵌套路由
	嵌套路由也称之为子路由, 就是在被切换的组件中又切换其它子组件
	例如: 在one界面中又有两个按钮, 通过这两个按钮进一步切换one中的内容

7. 命名视图
	1.什么是命名视图?
		命名视图类似于具名插槽思想, 都是让不同的出口显示不同的内容
		命名视图就是当路由地址被匹配的时候同时指定多个出口, 并且每个出口中显示的内容不同
	2. 路由出口
    	1. 路由匹配到的组件将渲染在这里
    		和匿名插槽一样, 如果指定了多个router-view, 那么当路由地址被匹配之后, 多个router-view中显示的内容是一样的
    		<router-view></router-view>
    		<router-view></router-view>
   		2. 和具名插槽一样, 如果想同时显示多个不同的组件, 那么可以给出口指定名称
        	1. 路由规则中给组件起名称
        	2. 出口中指定显示哪个名称的组件

8. watch属性
	1.什么是Watch属性?
		Watch属性是专门用于监听数据变化的, 只要数据发生了变化, 就会自动调用对应数据的回调方法
	2.Watch监听路由变化
		Watch属性不仅仅能够监听数据的变化, 还能够监听路由地址的变化
		在企业开发中我们可以通过Watch来判断当前界面是从哪个界面跳转过来的
```

# 13. vue生命周期方法

```
1. Vue生命周期方法分类
	1. 创建期间的生命周期方法
    	beforeCreate:
    	created:
    	beforeMount:
    	mounted:
	2. 运行期间的生命周期方法
    	beforeUpdate:
    	updated:
	3. 销毁期间的生命周期方法
    	beforeDestroy:
    	destroyed：

2. vue实例中可以使用生命周期方法
	Vue实例对象可以看做是一个大的组件, 我们自定义的组件可以看做是一个小的组件，
	那么大的组件中可以使用的属性和方法, 在小的组件中也可以使用
    
    例如: 在Vue实例中我们可以添加data, methods, 那么在自定义的组件中也可以添加data, methods
    所以Vue实例中可以使用生命周期方法, 组件中也可以使用生命周期方法
```

# 14. vue特殊属性

```
1.Vue特殊特性
	数据驱动界面更新, 无需操作DOM来更新界面，在Vue中想要拿到DOM元素可以通过ref获取

2.ref使用
	1. 在需要获取的元素上添加ref属性. 例如: <p ref="mypp">我是段落</>
	2. 在使用的地方通过 this.$refs.xxx获取, 例如 this.$ref.myppp

3.ref特点
	ref添加到元素DOM上, 拿到的就是元素DOM
	ref添加到组件上, 拿到的就是组件
```

# 15. vue-render函数

```
1. Vue渲染组件的两种方式
	1. 先定义注册组件, 然后在Vue实例中当做标签来使用
	2. 先定义注册组件, 然后通过Vue实例的render方法来渲染

2.两种渲染方法的区别
	1. 当做标签来渲染, 不会覆盖Vue实例控制区域
	2. 通过render方法来渲染, 会覆盖Vue实例控制区域
```

# 16. 基本语法综合

```
1. 内容渲染指令
	v-text
	{{ }}
	v-html

2. 属性绑定指令
	v-bind（单向数据绑定）
	v-model（双向数据绑定）

3. 事件绑定指令
	v-on

4. 事件对象event
	$event 是vue 提供的特殊变量，用来表示原生的事件参数对象event

5. 事件修饰符
	.prevent
	.stop
	.capture
	.once
	.self

6. 按键修饰符

7. v-model指令的修饰符（上述v-on总结已述说）
	.number
	.trim
	.lazy

8. 条件渲染指令
	v-if
	v-show

9. 列表渲染指令
	v-for

10. 计算属性（methods）和函数（methods）

11. 过滤器filter

12. 组件component

13. 全局数据共享Vuex

14. 特殊属性

15. 生命周期方法

16. vue-render函数


后续待完善整理！
```

